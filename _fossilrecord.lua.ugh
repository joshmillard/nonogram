module(..., package.seeall);

-- futz with some nonogram stuff

--[[ TODO
	- add noise/flash feedback for errors
	- add end-puzzle small-size pixel rendering
	- add tracking of moves/errors

--]]

puzzle_xoff = 200
puzzle_yoff = 200
puzzle_tilesize = 20

puzzle_name = "default"

tiles = {} -- our 2D array of game tiles
tiles_x = 0
tiles_y = 0
cluesx = {} -- clue lists for each row
cluesy = {} -- clue lists for each column

known = {} -- our solution-in-progress of the game board
errors = 0

difficulty = 0 -- random factor on random puzzles

peek = false -- are we peeking at the actual complete solution?

snd_error = {} -- sound to play when making a wrong move
snd_win = {} -- puzzle solving music!

-- tracking iterative solving
rownum = 1
colnum = 1
row_vs_col = "row"

puzlist_index = 1
puzlist = {"ducky", "dolphin", "gender", "prince", "stripes", "vassal", "longneck", "octopus"}

-- debug bullshit
leftmostdebug = ""
rightmostdebug = ""

function love.load()
	love.graphics.setMode(800, 800, false, true, 0)
	love.graphics.clear()

	load_sounds()
	generate_puzzle_randomly()
	reset_puzzle()
end

function love.update(dt)
	local md = love.mouse.isDown("l","r") -- are l or r button down?
	local mleft = love.mouse.isDown("l")
	local mright = love.mouse.isDown("r")
	local mx = love.mouse.getX()
	local my = love.mouse.getY()

	if md == true then
		-- lets see if we need to reveal a tile!
		if mx > puzzle_xoff + puzzle_tilesize and mx < (puzzle_xoff + (tiles_x + 1)*puzzle_tilesize) 
			and my > puzzle_yoff + puzzle_tilesize and my < (puzzle_yoff + (tiles_y + 1)*puzzle_tilesize) then
			
			-- we're on the board!  Check which tile we're over and try revealing
			local tx = math.ceil((mx - puzzle_xoff) / puzzle_tilesize) - 1
			local ty = math.ceil((my - puzzle_yoff) / puzzle_tilesize) - 1
		
			-- we only do anything if the tile isn't already revealed
			if known[ty][tx] == 2 then
				if mleft == true then
					if tiles[ty][tx] == 0 then
						-- guessed wrong that it was empty
						errors = errors + 1
						love.audio.play(snd_error)
					end
					-- reveal a full tile
					known[ty][tx] = tiles[ty][tx]
				elseif mright == true then
					if tiles[ty][tx] == 1 then
						-- guessed wrong that it was full!
						errors = errors + 1
						love.audio.play(snd_error)
					end
					known[ty][tx] = tiles[ty][tx]
				end
			end

		end
					
	end
end

function love.draw()

	love.graphics.setColor(200,200,100)
	love.graphics.print(puzzle_name, 20, 20)
	love.graphics.print(tiles_x .. "x" .. tiles_y, 20, 35)
	love.graphics.print("Errors: " .. errors, 20, 60)
	love.graphics.print("Difficulty: " .. difficulty, 20, 75)

	-- draw tiles
	for i=1, tiles_y do
		for j=1, tiles_x do
			-- tile background
			love.graphics.setColor(50,50,50)
			love.graphics.rectangle("fill", puzzle_xoff + puzzle_tilesize * j, 
				puzzle_yoff + puzzle_tilesize * i, puzzle_tilesize, puzzle_tilesize)
			love.graphics.setColor(100,100,100)
			love.graphics.rectangle("line", puzzle_xoff + puzzle_tilesize * j,
        puzzle_yoff + puzzle_tilesize * i, puzzle_tilesize, puzzle_tilesize)

			local matrix = {}
			if peek == true then
				matrix = tiles -- show the actual complete layout
			else
				matrix = known -- show the solution-in-progress
			end

			-- tile state
			if matrix[i][j] == 1 then
				love.graphics.setColor(100,200,100)
				love.graphics.rectangle("fill", puzzle_xoff + puzzle_tilesize * j + 2,
        	puzzle_yoff + puzzle_tilesize * i + 2, puzzle_tilesize - 4, puzzle_tilesize - 4)
			elseif matrix[i][j] == 0 then
				love.graphics.setColor(255,0,0)
				love.graphics.line(puzzle_xoff + puzzle_tilesize * j + 5, puzzle_yoff + puzzle_tilesize * i + 5,
					puzzle_xoff + puzzle_tilesize * (j+1) - 5, puzzle_yoff + puzzle_tilesize * (i+1) - 5)
				love.graphics.line(puzzle_xoff + puzzle_tilesize * j + 5, puzzle_yoff + puzzle_tilesize * (i+1) - 5,
          puzzle_xoff + puzzle_tilesize * (j+1) - 5, puzzle_yoff + puzzle_tilesize * i + 5)
			else
				-- draw fog of war!  Or just don't draw anything over the background, for now, 
				--  since that works just fine.
			end
		end
	end	
		
	-- and print clues

	for i=1, tiles_y do	
		local len = table.getn(cluesx[i])
		if len == 0 then
			-- special case: empty clue list, we should display a "0"
			love.graphics.setColor(40,40,80)
			love.graphics.print(0, puzzle_xoff + 3, puzzle_yoff + puzzle_tilesize*i + 3)
		end
		for k=len, 1, -1 do
			local char
			if row_is_solved(i) then
				love.graphics.setColor(40,40,80)			
			else
				love.graphics.setColor(100,100,200)
			end
			love.graphics.print(cluesx[i][len + 1 - k], 
				puzzle_xoff - (k-1)*15 + 3, 
				puzzle_yoff + puzzle_tilesize*i + 3) 
		end
	end

	for i=1, tiles_x do
		local len = table.getn(cluesy[i])
    if len == 0 then
      -- special case: empty clue list, we should display a "0"
      love.graphics.setColor(40,40,80)
      love.graphics.print(0, puzzle_xoff + puzzle_tilesize*i + 3, puzzle_yoff + 3)
    end
		for k=len, 1, -1 do
  	  local char
			if column_is_solved(i) then
				love.graphics.setColor(40,40,80)
			else
  	   	love.graphics.setColor(100,100,200)
			end
  	  love.graphics.print(cluesy[i][len + 1 - k], 
				puzzle_xoff + puzzle_tilesize*i + 6, 
				puzzle_yoff - (k-1)*15 + 3)
  	end
	end

	-- draw segmented-by-five overlay for easier counting
	love.graphics.setColor(200,200,100)
	love.graphics.rectangle("line", puzzle_xoff + puzzle_tilesize, puzzle_yoff + puzzle_tilesize, 
		puzzle_tilesize*tiles_x, puzzle_tilesize*tiles_y +1)

	for i=6, tiles_x, 5 do
		love.graphics.line(puzzle_xoff + i*puzzle_tilesize, puzzle_yoff + puzzle_tilesize, 
			puzzle_xoff + i*puzzle_tilesize, puzzle_yoff + (tiles_y+1)*puzzle_tilesize)
	end

  for i=6, tiles_y, 5 do
    love.graphics.line(puzzle_xoff + puzzle_tilesize, puzzle_yoff + i*puzzle_tilesize,
      puzzle_xoff + (tiles_x+1)*puzzle_tilesize, puzzle_yoff + i*puzzle_tilesize)
  end

	-- draw edgemost







--[[
TODO: figure out what the like six hundred fucking lines of code I managed to delete with some
little vi keystroke here were and replace them, if I can even be bothered to because motherFUCKER
that's terrible bullshit and I hadn't backed this up at all.
--]]
[[--
clue, pad out the tiles between that and the clue length with Fulls.

TODO: Figure out why this doesn't seem to work when there are padding Empties at the edge
--]]
local FILL_OUT_NEAR_EDGE_CLUES = true
if FILL_OUT_NEAR_EDGE_CLUES then
	local padding = false
	local padcount = 0
	for i=1, clues[1] do
		if padding then
			if s[i] ~= 1 then
				s[i] = 1
				padcount = padcount + 1
			end
		elseif s[i] == 1 then
			padding = true
		end
	end
	if padcount > 0 then
		print("Padded " .. padcount .. " on left near-edge clue!")
	end

	-- and backwards
	padding = false
	padcount = 0
	for i=len, len - clues[table.getn(clues)] + 1, -1 do
		if padding then
			if s[i] ~= 1 then
				s[i] = 1
				padcount = padcount + 1
			end
		elseif s[i] == 1 then
			padding = true
		end
	end
	if padcount > 0 then
		print("Padded " .. padcount .. " on right near-edge clue!")
	end
end

--[[
If there's only one clue on the list *and* we have at least one Full tile in the line, then
we can safely mark as empty all the Uncertain tiles farther from the Full tile than the clue
length.

While we're at it, we're filling gaps between islands of Full tiles on the line too since
for a single clue they must all be constituents.
--]]
local PAD_EMPTIES_AROUND_SINGLE_CLUE = true
if PAD_EMPTIES_AROUND_SINGLE_CLUE then
	if table.getn(clues) == 1 then

		local status = ""
		local start = 0 -- indices
		local finish = 0
		-- lets go find where our first and last Full tiles are
		for i=1, len do
			if s[i] == 1 and start == 0 then
				start = i
				finish = i
				-- this is our first Full tile
			elseif s[i] == 1 and start > 0 then
				finish = i
				-- this is our last Full tile, keep bumping it back as we proceed along line finding more
			end
		end
		if start ~= 0 then
			status = status .. "found start/finish: " .. start .. "/" .. finish
		end

		-- and lets fill in any gaps between start and finish with Full tiles
		local gaplist = ""
		for i=start, finish do
			if s[i] == 2 then
				s[i] = 1
				gaplist = gaplist .. " " .. i
				-- TODO: print/store changes here
			end
		end
		if gaplist ~= "" then
			status = status .. "; filled gaps at" .. gaplist
		end

		local fillerlist = ""
		local runlength = (finish - start) + 1 -- how many tiles in a row do we have?
		local boundary = clues[1] - runlength -- and how much less is that than the clue length?
		-- now let's pad empties on the outskirts of this clue's known parts
		if start > 0 then
			for i=1, start - boundary - 1 do
				if s[i] == 2 then
					s[i] = 0
					fillerlist = fillerlist .. " " .. i
				end
			end
		end
		if finish > 0 then
			for i=finish + boundary + 1, len do
				if s[i] == 2 then
					s[i] = 0
					fillerlist = fillerlist .. " " .. i			
				end
			end
		end	
		if fillerlist ~= "" then
			status = status .. "; add Empty at" .. fillerlist
		end

		if status ~= "" then
			print("Single clue..." .. status)
		end
	end
end

--[[
If the edgemost clue is longer than the edgemost string of Uncertain tiles bounded by an Empty,
then those Uncertain tiles cannot contain the edgemost clue and thus must be Empty as well.
--]]
local EDGE_CLUE_WONT_FIT = true
if EDGE_CLUE_WONT_FIT then

	local start = 0
	local finish = 0
	local abort = false
	-- locate the first
	for i=1, len do
		if s[i] == 2 then
			-- found our first uncertain tile
			start = i
			break
		elseif s[i] == 1 then
			-- wait, we found a Full tile? This is not gonna work, then, let's just bail.
			abort = true
			break
		end	
	end
	-- if we never assigned a new value to start, we're in bad shape.
	if start == 0 then
		abort = true
--		print("ECWF bail: found no start")
	end
	-- if we didn't trip across a Full, let's keep going.
	if abort == false then
		for i=start + 1, len do		
			if s[i] == 0 then
				-- we've found a terminating Empty tile, let's stop
				finish = i
				break
			elseif s[i] == 1 then
				-- oh no, a Full tile!  We're in the wrong business.
				finish = 0
				abort = true
				break
			end
		end
		if finish == 0 then
			abort = true
--			print("ECWF bail: found no finish")
		end
	end
	-- if we STILL didn't trip across a full, we can actually test this thing.
	if abort == false then
		local changes = "ECWF success: edge clue won't fit, Emptying"
		if clues[1] > finish - start then
			for i=start, finish - 1 do
				s[i] = 0
				-- note changes!
				changes = changes .. " " .. i
			end
			print(changes)
		else
--			print("ECWF fail: clue fits in gap")
		end
	end

	-- aaaand let's do it all again from the rightmost edge
	start = 0
	finish = 0
	abort = false
	-- locate the first
	for i=len, 1, -1 do
		if s[i] == 2 then
			-- found our first uncertain tile
			start = i
			break
		elseif s[i] == 1 then
			-- wait, we found a Full tile? This is not gonna work, then, let's just bail.
			abort = true
			break
		end	
	end
	-- if we never assigned a new value to start, we're in bad shape.
	if start == 0 then
		abort = true
--		print("ECWFr bail: found no start")
	end
	-- if we didn't trip across a Full, let's keep going.
	if abort == false then
		for i=start - 1, 1, -1 do		
			if s[i] == 0 then
				-- we've found a terminating Empty tile, let's stop
				finish = i
				break
			elseif s[i] == 1 then
				-- oh no, a Full tile!  We're in the wrong business.
				finish = 0
				abort = true
				break
			end
		end
		if finish == 0 then
			abort = true
--			print("ECWFr bail: found no finish")
		end
	end
	-- if we STILL didn't trip across a full, we can actually test this thing.
	if abort == false then
		local changes = "ECWFr success: edge clue won't fit, Emptying"
		if clues[table.getn(clues)] > start - finish then
			for i=start, finish + 1, -1 do
				s[i] = 0
				-- note changes!
				changes = changes .. " " .. i
			end
			print(changes)
		else
--			print("ECWFr fail: clue fits in gap")
		end
	end

end

--[[
If the largest clue in the clue list is n, then we know any run of n Full tiles in a row
must be bounded on either side by an Empty tile.  This can be especially useful for small
max clue sizes, like strings of 1 or 2 e.g. {1 1 1 1}.

A smarter version of this would set maxsize to be the size of the largest as-yet-unbounded
clue in the list, so if e.g. cluelist is {2 1 1 1} but the 2 clue is already a settled
matter, the effective max clue size would be 1 after all.  And in a sense this partly
happens already with recursive calls that strip off clues, but only for the case of the 
bound clue being edgemost vs. being stranded in the middle.
--]]
local BOUND_MAXCLUESIZE_CLUES = true
if BOUND_MAXCLUESIZE_CLUES then
	local maxsize = 0
	-- figure out what our largest clue size in the list is
	for i,v in ipairs(clues) do
		if v > maxsize then
			maxsize = v
		end
	end
	if maxsize > 0 then
		-- technically it makes no sense to get here with an empty clue list since a previous
		-- rule would have caught that, but, hey, let's be extra sane
		local currentsize = 0
		for i=1, len do
			-- count consecutive Fulls, reset whenever we encounter an Empty or an Uncertain
			if s[i] == 1 then
				currentsize = currentsize + 1
			else
				currentsize = 0
			end
			-- if we hit the size limit, we know we're looking at the last tile of a maxsize clue
			if currentsize == maxsize then
				local pre = i - maxsize
				local post = i + 1
				if pre > 0 then
					-- let's be sure we're not butted up against the left edge
					if s[pre] == 2 then
						s[pre] = 0
						print("Binding maxsize=" .. maxsize .. " clue on left at " .. pre)
					end
				end
				if post <= len then
					if s[post] == 2 then
						s[post] = 0
						print("Binding maxsize=" .. maxsize .. " clue on right at " .. post)		
					end
				end
			end
		end
	end
end

--[[
We look for a Full tile in a near-edge Empty-free run at least as big as the first clue 
but no bigger than the first clue plus the second clue (no gap space), bounded by an Empty.
That space *must* be occupied solely by the first clue, so we send that clue and the bounded
region to a recursive call of solve_line().

e.g. 
{3,1} __FE_____
      ^^

{3,1} __F_E_____
       ^

{4,2} ___F__E___
        ^  
--]]
local FILL_EDGEMOST_CLUES = true
if FILL_EDGEMOST_CLUES then
	if table.getn(clues) > 1 then
		-- pretty sure there's not utility to this on a single clue since we've got more specific
		-- rules dealing with that case already
		local abort
		local found
		local bound

		abort = false
		found = false
		bound = 0
		
		for i=1, clues[1] do
			if s[i] == 0 then
				-- bounded space is too small for clue!
				-- TODO: in a different universe than this one, we might recurse at this point to check the
				-- full clue list against the remaining line...
				abort = true
				break
			elseif s[i] == 1 then
				-- we found at least one Full tile!
				found = true
			end
		end

		if found and abort == false then
			-- if we did find a Full and didn't trip on an Empty, let's check for an appropriate
			-- bounding Empty as well
			for i=clues[1] + 1, clues[1] + clues[2] + 1 do
				if s[i] == 0 then
					-- found an Empty, record the position and get out of here
					bound = i
					break
				end
			end

			if bound > 0 then
				print("  Fill Edgemost Clues: recursing...")
				s = recurse_solve_line(clues, 1, 1, s, 1, bound)
			end
		end
	end

end


local CHECK_FOR_BOUNDING_FULLS = true
if CHECK_FOR_BOUNDING_FULLS then
	-- CHECK FOR BOUNDING FULLS and pad them out with an Empty capper

	local start = 1
	local finish = len
	local cluestart = 1
	local cluefinish = table.getn(clues)

	if table.getn(clues) > 0 then
		local firstclue = clues[1]
		local lastclue = clues[table.getn(clues)]

		-- test and pad from the front of the line
		if s[1] == 1 then
			-- got a Full tile on the edge! 
			for i=1, firstclue do
				s[i] = 1
			end
			s[firstclue + 1] = 0
			start = firstclue + 2
			cluestart = cluestart + 1
		end

		-- and ditto from the back
		--  TODO: but only if more than one clue?
		if s[len] == 1 then
			for i=len, (len - lastclue) + 1, -1 do
				s[i] = 1
			end
			s[len - lastclue] = 0
			finish = len - lastclue - 1
			cluefinish = cluefinish - 1
		end

		-- and let's recurse with this exciting new info
		if (start > 1 or finish < len) and start <= finish  then
print("Found bounding fulls, recursing subline " .. start .. "-" .. finish .. "...")
			s = recurse_solve_line(clues, cluestart, cluefinish, s, start, finish)
print("...done.")
		end
	end
end
		
local CHECK_FOR_BOUNDING_EMPTIES = true
if CHECK_FOR_BOUNDING_EMPTIES then
	-- CHECK FOR BOUNDING EMPTIES and call this function recursively on the bound substring 
	local start = 1
	local finish = len
	for i=1, len do
		if s[i] ~=0 then
			break
		else
			start = start + 1
		end
	end
	for i=len, start + 1, -1 do
		if s[i] ~= 0 then
			break
		else
			finish = finish - 1
		end
	end
	-- assuming we actually found any bounding empties:	
	-- make a recursive call on the subline between our bounding empties, sending the
	-- whole darn clue list since the empties don't account for any clues
	if start > 1 or finish < len then
--DEBUG
print("Found bounding empties, recursing subline " .. start .. "-" .. finish .. "...")
		s = recurse_solve_line(c, 1, table.getn(c), s, start, finish)
print("...done.")
	end
end	

	return s
end

-- utility function to make it really simple to call solve_line() recursively
--[[
clue_start and clue_end are indexes into the passed clues list; the call that follows
will be passed a sublist of clues defined by those offsets.

Ditto line and line_start/line_end; we pass a subline to the recursive call.

After that, we take the subline we get back, glue the prefix and suffix portions
back on to it, and return that to the originating solve_line() call.
--]]
function recurse_solve_line(clues, clue_start, clue_end, line, line_start, line_end)
  local prefix = {}
  local suffix = {}
  local subline = {}
	local newline = {}

	local len = table.getn(line)

	-- make newline a fresh copy of line
	for i=1, len do
		table.insert(newline, tonumber(line[i]))
	end

	-- split solution line into prefix, subline, and suffix
  for i=1, line_start - 1 do
		table.insert(prefix, tonumber(newline[i]))
  end
  for i=line_end + 1, len do
    table.insert(suffix, tonumber(newline[i]))
  end
  for i=line_start, line_end do
    table.insert(subline, tonumber(newline[i]))
  end

	re_prefix = line_to_string(prefix)
	re_suffix = line_to_string(suffix)
	local re_subline = line_to_string(subline)
	print(re_prefix .. "> " .. re_subline .. " <" .. re_suffix .. " >>>")

	-- extract clue sublist from clues
	local sublist = {}
	for i=clue_start, clue_end do
		table.insert(sublist, tonumber(clues[i]))
	end

  -- now, recurse if and only if we have successfully discovered padding on either end; we 
	-- don't want to recurse Just Because, since that's asking for a stack overflow
  if table.getn(subline) > 0 and (table.getn(prefix) > 0 or table.getn(suffix) > 0) then
	  local newsub = solve_line(sublist, subline)
 		newline = {}
	  for i,v in ipairs(prefix) do
      table.insert(newline, tonumber(v))
    end
    for i,v in ipairs(newsub) do
      table.insert(newline, tonumber(v))
    end
    for i,v in ipairs(suffix) do
      table.insert(newline, tonumber(v))
    end
  end

	local temp_newline = line_to_string(newline)
	print("> " .. temp_newline .. " < <<<")

	return newline

end

-- given a piece of a game state line, return a string of that state
function line_to_string(line)
	local newstr = ""
	for i=1, table.getn(line) do
		newstr = newstr .. line[i]
	end
	return newstr
end
